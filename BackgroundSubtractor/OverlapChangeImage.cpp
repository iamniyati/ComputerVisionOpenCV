/**
 * This program shows how to use background subtraction
 * and create a a picture with several movements
 * of the object detected in one
 *
 * @version   $Id$ 1.0 HW03_Shah_Niyati.cpp
 *
 * @author   Niyati Shah
 *
 * Cite: http://docs.opencv.org/master/d1/dc5/tutorial_background_subtraction.html
 * //http://answers.opencv.org/question/32140/draw-largestrect-contour-on-this-image/
 *
 * Worked With: Yash Jain, Antara Mishra
 *	$Log$
 */


#include <opencv2/opencv.hpp>
#include <iostream>




using namespace cv;
using namespace std;


// Create a few global variables
Mat frame; //current frame
Mat fgMaskMOG2; //fg mask fg mask generated by MOG2 method
Ptr<BackgroundSubtractor> pMOG2; //MOG2 Background subtractor
char keyboard; //input from keyboard
bool flag = true;

// Function to check if two rectangles overlap of not
// by performing intersection and then
// checking if there is any non zero elements left.
// loc will contain the loaction of non zero elements.
// if non presnet then it means that there is no non zero
// lement which means taht it does not overlap.
bool checkOverlap(Mat A, Mat B)
{

    Mat D = A&B; // Intersection between the two images
    imshow("D",D);

    vector<Point>  loc;

    findNonZero(D, loc); // find non zero locations

    if (loc.size() > 0){ // if any location found then there is overlao.
        return true;

    }else{
        return false;
    }

}

// Fucntion to seperate background and foreground.
//then select the correct ROI
// and form the output image
void processVideo(char* videoFilename){

    Mat history;        // object to store previous correct ROT
    Mat ContinuousROI;              //object to store all previous selected ROI in one image.
    Mat OutputImage;            // final output image
    Mat boundRect;              // image that stores the filled bounding rectangle

    //create the capture object
    VideoCapture capture(videoFilename);
    if(!capture.isOpened()){
        //error in opening the video input
        cerr << "Unable to open video file: " << videoFilename << endl;
        exit(EXIT_FAILURE);
    }
    //read input data. ESC or 'q' for quitting
    keyboard = 0;

    while (keyboard != 'q' && keyboard != 27 ) {
        //while( keyboard != 'q' && keyboard != 27 ){
        //read the current frame
        if (!capture.read(frame)) {
            cerr << "Unable to read next frame." << endl;
            cerr << "Exiting..." << endl;
            exit(EXIT_FAILURE);
        }
        //update the background model
        pMOG2->apply(frame, fgMaskMOG2);


        double largest_area = 0;    // find the largest contour by area
        int largest_contour_index = 0;      // to store index of largest contour
        Rect bounding_rect;     // store the rectangle that will bound the contour

        Mat thr(fgMaskMOG2.rows, fgMaskMOG2.cols, CV_8UC1); // to store thresholded and median blured image
        Mat boundRect(fgMaskMOG2.rows, fgMaskMOG2.cols, CV_8UC1, Scalar::all(0)); // stores the image with contours
        threshold(fgMaskMOG2, thr, 25, 255, THRESH_BINARY); //Threshold the gray
        medianBlur(thr, thr, 5); // perform median blur

        vector<vector<Point>> contours; // Vector for storing contour
        vector<Vec4i> hierarchy; // vector to store hierarchy relation of contours

        findContours(thr, contours, hierarchy, CV_RETR_CCOMP, CV_CHAIN_APPROX_SIMPLE); // Find the contours in the image

        for (int i = 0; i < contours.size(); i++) // iterate through each contour.
        {
            double a = contourArea(contours[i]);  //  Find the area of contour
            if (a > largest_area) {
                largest_area = a;
                largest_contour_index = i;                //Store the index of largest contour
                bounding_rect = boundingRect(contours[i]); // Find the bounding rectangle for biggest contour
            }
        }
        // Get diagonal points of rectangle and area
        Point pt1, pt2;
        pt1.x = bounding_rect.x;
        pt1.y = bounding_rect.y;
        pt2.x = bounding_rect.x + bounding_rect.width;
        pt2.y = bounding_rect.y + bounding_rect.height;
        double Area = bounding_rect.width * bounding_rect.height;

        // Draw the bounding rectangle which is completely filled.
        Scalar color(255, 255, 255);
        drawContours(boundRect, contours, largest_contour_index, color, CV_FILLED, 8,
                     hierarchy); // Draw the largest contour using previously stored index
        rectangle(boundRect, pt1, pt2, color, CV_FILLED, 8, 0);

        // Now check if it is the first frame taht is being used
        // if yes then initialise a history frame to store previous.
        // and initialise the output iamge.
        if (flag) {
            history = fgMaskMOG2;
            flag = false;
            frame.copyTo(OutputImage);
            ContinuousROI = history;
        }
        // check if the rectangles overlap
        if (!checkOverlap(history, boundRect)) {

            // check if the area is within range
            if (Area >= 1000 & Area < 13000) {
                // copy the mask part of frame to output
                frame.copyTo(OutputImage, fgMaskMOG2);

            }
            //update the history
            history = boundRect;
            // trying to get the continous history
            bitwise_or(ContinuousROI,history,ContinuousROI);

        }
        // to see each part of the things being performed
        imshow("frame", frame);
        imshow("FG Mask MOG 2", fgMaskMOG2);
        imshow("boundRect", boundRect);
        imshow("output", OutputImage);

        //get the input from the keyboard
        keyboard = (char) waitKey(30);
        // writing the output.
        imwrite("out.jpg", OutputImage);
    }

    //delete capture object
    capture.release();


}
int main( int argc, char** argv )
{


    if (argc != 2) {
        cout << "Error: Too few arguments, include image file name" << endl;
        return -2;

    } else {

        //create GUI windows
        namedWindow("Frame");
        namedWindow("FG Mask MOG 2");
        //create Background Subtractor objects
        pMOG2 = createBackgroundSubtractorMOG2(); //MOG2 approach

        processVideo(argv[1]);
        //destroy GUI windows
        destroyAllWindows();
    }
    return 0;
}